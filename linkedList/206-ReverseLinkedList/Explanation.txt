Problem Statement:

Given the head of a singly linked list, reverse the list, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000
 

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

Explanation:
I chose to solve this algorithm iteratively and not recursively for better performance. To reverse a linked list, all we need to do
is continuously move the original head node, by reassigning the original head node (let's call it ptr) .next node to the head of the list.
This way, each iteration will move one more node ahead of the ptr node, until ptr.next is null.

Time Complexity: O(n) one pass!

Space Complexity: O(1) no additional data structures!

To do it recursively: We could implement this algorithm by creating a function that swaps ptr and ptr.next, and call that function
on each time we move ptr.